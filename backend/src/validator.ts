import type { Transcript, TimestampCandidate } from './types';
import { calculateTotalDuration, SECONDS_PER_MINUTE } from './time-utils';
import {
  VALIDATION_CONFIG,
  getIntroTitle,
  getFallbackTitle,
  createValidationStats,
  type ValidationStats,
} from './validation-config';

/**
 * Validate timestamps generated by AI.
 * Implements multiple layers of anti-hallucination validation:
 * 1. Confidence threshold filtering
 * 2. Time bounds validation
 * 3. Minimum spacing enforcement
 * 4. Empty title rejection
 * 
 * @param timestamps - Array of timestamp candidates from AI
 * @param transcript - The transcript used for validation context
 * @param minConfidence - Minimum confidence threshold (default from config)
 * @param minDuration - Minimum spacing between timestamps (default from config)
 * @returns Validated and filtered timestamps
 */
export function validateTimestamps(
  timestamps: TimestampCandidate[],
  transcript: Transcript,
  minConfidence: number = VALIDATION_CONFIG.DEFAULT_MIN_CONFIDENCE,
  minDuration: number = VALIDATION_CONFIG.DEFAULT_MIN_SEGMENT_DURATION
): TimestampCandidate[] {
  const validated: TimestampCandidate[] = [];
  const stats = createValidationStats();
  stats.totalCandidates = timestamps.length;
  let lastTime = -minDuration;

  // Calculate total duration using centralized utility
  let totalDuration = calculateTotalDuration(transcript.segments);
  
  // Fallback: if duration is 0, estimate based on number of segments
  if (totalDuration === 0 && transcript.segments.length > 0) {
    totalDuration = transcript.segments.length * VALIDATION_CONFIG.FALLBACK_SECONDS_PER_SEGMENT;
    console.log(`[Validator] WARNING: Duration was 0, estimated ${totalDuration}s based on ${transcript.segments.length} segments`);
  }
  
  // Cap at maximum video duration
  totalDuration = Math.min(totalDuration, VALIDATION_CONFIG.MAX_VIDEO_DURATION);
  
  console.log(`[Validator] Video duration: ${totalDuration}s (${Math.floor(totalDuration / SECONDS_PER_MINUTE)} minutes)`);

  for (const ts of timestamps) {
    // Validation 1: Minimum confidence
    if ((ts.confidence ?? 0) < minConfidence) {
      console.log(`[Validator] Rejected "${ts.title}" at ${ts.time}s - Low confidence: ${ts.confidence} < ${minConfidence}`);
      stats.rejectedByConfidence++;
      continue;
    }

    // Validation 2: Timestamp is within video duration (with tolerance for rounding errors)
    const maxAllowedTime = totalDuration * VALIDATION_CONFIG.DURATION_TOLERANCE_FACTOR;
    if (ts.time < 0 || ts.time > maxAllowedTime) {
      console.log(`[Validator] Rejected "${ts.title}" - Time out of bounds: ${ts.time}s (video: 0-${totalDuration}s)`);
      stats.rejectedByBounds++;
      continue;
    }

    // Validation 3: Minimum spacing
    if (ts.time - lastTime < minDuration) {
      console.log(`[Validator] Rejected "${ts.title}" at ${ts.time}s - Too close to previous: ${ts.time - lastTime}s < ${minDuration}s`);
      stats.rejectedBySpacing++;
      continue;
    }

    // Validation 4: Title is not empty
    if (!ts.title?.trim()) {
      console.log(`[Validator] Rejected timestamp at ${ts.time}s - Empty title`);
      stats.rejectedByEmptyTitle++;
      continue;
    }

    validated.push(ts);
    lastTime = ts.time;
  }

  // Update stats
  stats.validatedCount = validated.length;

  // Log validation results with detailed statistics
  console.log(`[Validator] Validation complete:`);
  console.log(`[Validator]   - Total candidates: ${stats.totalCandidates}`);
  console.log(`[Validator]   - Validated: ${stats.validatedCount}`);
  console.log(`[Validator]   - Rejected by confidence: ${stats.rejectedByConfidence}`);
  console.log(`[Validator]   - Rejected by bounds: ${stats.rejectedByBounds}`);
  console.log(`[Validator]   - Rejected by spacing: ${stats.rejectedBySpacing}`);
  console.log(`[Validator]   - Rejected by empty title: ${stats.rejectedByEmptyTitle}`);
  
  if (validated.length > 0) {
    console.log(`[Validator] Accepted timestamps:`);
    validated.forEach(ts => {
      const mins = Math.floor(ts.time / SECONDS_PER_MINUTE);
      const secs = Math.floor(ts.time % SECONDS_PER_MINUTE);
      console.log(`[Validator]   - ${mins}:${secs.toString().padStart(2, '0')} "${ts.title}" (confidence: ${ts.confidence})`);
    });
  }
  
  // Add initial timestamp if not present (using language-aware title)
  if (validated.length > 0 && validated[0].time > VALIDATION_CONFIG.INTRO_TIMESTAMP_THRESHOLD) {
    const firstSegment = transcript.segments[0];
    const introTitle = getIntroTitle(transcript.language);
    console.log(`[Validator] Adding intro timestamp at 0:00 (${introTitle})`);
    stats.introAdded = true;
    validated.unshift({
      time: 0,
      title: introTitle,
      confidence: 1.0,
      evidence: firstSegment?.text ?? '',
    });
  }
  
  // Only add default intro if no timestamps at all (AI failed completely)
  if (validated.length === 0) {
    const firstSegment = transcript.segments[0];
    const fallbackTitle = getFallbackTitle(transcript.language);
    console.log(`[Validator] WARNING: No valid timestamps generated. Adding fallback intro (${fallbackTitle}).`);
    stats.introAdded = true;
    validated.push({
      time: 0,
      title: fallbackTitle,
      confidence: 1.0,
      evidence: firstSegment?.text ?? '',
    });
  }

  // Sort by time
  validated.sort((a, b) => a.time - b.time);

  return validated;
}

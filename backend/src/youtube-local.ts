/**
 * Local YouTube Transcript Service
 * 
 * This module provides YouTube transcript extraction with local Whisper fallback
 * instead of OpenAI's Whisper API. It runs completely locally without requiring
 * any paid APIs.
 */

import { YoutubeTranscript } from 'youtube-transcript';
import type { Transcript, TranscriptSegment } from './types';
import { parseYouTubeError } from './errors';
import { getTranscriptWithLocalWhisper } from './local-whisper';
import { getCachedTranscript, cacheTranscript } from './cache';
import { msToSeconds, formatTimestamp as formatTime, calculateTotalDuration } from './time-utils';
import { VALIDATION_CONFIG } from './validation-config';

// Re-export extractVideoId and other utilities from youtube.ts
export { extractVideoId, getVideoInfo, formatTimestamp, formatTranscriptForAI } from './youtube';
import { extractVideoId, getVideoInfo, calculateTranscriptCoverage, checkTranscriptCoverage } from './youtube';

/**
 * Get transcript from YouTube video using local services only
 * First tries to get existing subtitles, then falls back to local Whisper speech-to-text
 * Also checks transcript coverage and falls back to local Whisper if coverage is too low
 */
export async function getTranscriptLocal(
  videoId: string,
  preferredLanguage: string = 'pt',
  useWhisperFallback: boolean = true,
  forceWhisper: boolean = false
): Promise<{ 
  transcript: Transcript; 
  fromCache: boolean; 
  videoTitle?: string;
  videoDuration?: number;
  transcriptCoverage?: number;
  whisperReason?: 'no_subtitles' | 'low_coverage' | 'force_whisper';
}> {
  // If force Whisper, skip cache and subtitles
  if (forceWhisper) {
    console.log(`[YouTubeLocal] Force Whisper enabled, skipping subtitles for ${videoId}`);
    const whisperTranscript = await getTranscriptWithLocalWhisper(
      videoId,
      preferredLanguage
    );
    whisperTranscript.isAutoGenerated = false;
    cacheTranscript(videoId, preferredLanguage, whisperTranscript, 'whisper');
    const videoInfo = await getVideoInfo(videoId);
    const coverage = calculateTranscriptCoverage(whisperTranscript.segments, videoInfo.duration);
    return { 
      transcript: whisperTranscript, 
      fromCache: false, 
      videoTitle: videoInfo.title,
      videoDuration: videoInfo.duration,
      transcriptCoverage: coverage,
      whisperReason: 'force_whisper'
    };
  }

  // Get video info first
  const videoInfo = await getVideoInfo(videoId);
  console.log(`[YouTubeLocal] Video title: "${videoInfo.title}"`);
  
  // Check cache
  const cached = getCachedTranscript(videoId, preferredLanguage);
  if (cached) {
    const coverage = calculateTranscriptCoverage(cached.transcript.segments, videoInfo.duration);
    return { 
      transcript: cached.transcript, 
      fromCache: true, 
      videoTitle: videoInfo.title,
      videoDuration: videoInfo.duration,
      transcriptCoverage: coverage
    };
  }

  try {
    // Try to fetch transcript with preferred language
    console.log(`[YouTubeLocal] Trying to fetch ${preferredLanguage} subtitles for ${videoId}...`);
    const transcriptItems = await YoutubeTranscript.fetchTranscript(videoId, {
      lang: preferredLanguage,
    });
    console.log(`[YouTubeLocal] Found ${transcriptItems.length} subtitle segments`);

    // Treat empty transcript as failure - trigger fallback
    if (!transcriptItems || transcriptItems.length === 0) {
      console.log(`[YouTubeLocal] No subtitle segments found for ${videoId} in ${preferredLanguage}, treating as no subtitles`);
      throw new Error('NO_SUBTITLE_SEGMENTS');
    }

    const segments: TranscriptSegment[] = transcriptItems.map((item) => ({
      text: item.text,
      offset: msToSeconds(item.offset),
      duration: msToSeconds(item.duration),
    }));

    const transcript: Transcript = {
      videoId,
      language: preferredLanguage,
      segments,
      isAutoGenerated: true, // youtube-transcript doesn't distinguish
    };

    // Check transcript coverage - fall back to local Whisper if coverage is too low
    if (useWhisperFallback && videoInfo.duration > 0) {
      const coverageMeetsThreshold = checkTranscriptCoverage(segments, videoInfo.duration);
      if (!coverageMeetsThreshold) {
        console.log(`[YouTubeLocal] Transcript coverage too low, falling back to local Whisper for ${videoId}...`);
        try {
          const whisperTranscript = await getTranscriptWithLocalWhisper(
            videoId,
            preferredLanguage
          );
          whisperTranscript.isAutoGenerated = false;
          cacheTranscript(videoId, preferredLanguage, whisperTranscript, 'whisper');
          console.log(`[YouTubeLocal] Successfully re-transcribed with local Whisper due to low coverage`);
          const whisperCoverage = calculateTranscriptCoverage(whisperTranscript.segments, videoInfo.duration);
          return { 
            transcript: whisperTranscript, 
            fromCache: false, 
            videoTitle: videoInfo.title,
            videoDuration: videoInfo.duration,
            transcriptCoverage: whisperCoverage,
            whisperReason: 'low_coverage'
          };
        } catch (whisperError: any) {
          console.error(`[YouTubeLocal] Local Whisper fallback failed, using original transcript:`, whisperError.message);
          // Fall through to use the original transcript
        }
      }
    }

    // Cache the transcript
    cacheTranscript(videoId, preferredLanguage, transcript, 'youtube');

    const coverage = calculateTranscriptCoverage(segments, videoInfo.duration);
    return { 
      transcript, 
      fromCache: false, 
      videoTitle: videoInfo.title,
      videoDuration: videoInfo.duration,
      transcriptCoverage: coverage
    };
  } catch (error) {
    // Try English as fallback
    if (preferredLanguage !== 'en') {
      try {
        console.log(`[YouTubeLocal] Trying English subtitles for ${videoId}...`);
        const transcriptItems = await YoutubeTranscript.fetchTranscript(videoId, {
          lang: 'en',
        });
        console.log(`[YouTubeLocal] Found ${transcriptItems.length} English subtitle segments`);

        // Treat empty transcript as failure - trigger fallback
        if (!transcriptItems || transcriptItems.length === 0) {
          console.log(`[YouTubeLocal] No English subtitle segments found for ${videoId}, treating as no subtitles`);
          throw new Error('NO_SUBTITLE_SEGMENTS');
        }

        const segments: TranscriptSegment[] = transcriptItems.map((item) => ({
          text: item.text,
          offset: msToSeconds(item.offset),
          duration: msToSeconds(item.duration),
        }));

        const transcript: Transcript = {
          videoId,
          language: 'en',
          segments,
          isAutoGenerated: true,
        };

        // Check transcript coverage - fall back to local Whisper if coverage is too low
        if (useWhisperFallback && videoInfo.duration > 0) {
          const coverageMeetsThreshold = checkTranscriptCoverage(segments, videoInfo.duration);
          if (!coverageMeetsThreshold) {
            console.log(`[YouTubeLocal] English transcript coverage too low, falling back to local Whisper for ${videoId}...`);
            try {
              const whisperTranscript = await getTranscriptWithLocalWhisper(
                videoId,
                preferredLanguage
              );
              whisperTranscript.isAutoGenerated = false;
              cacheTranscript(videoId, preferredLanguage, whisperTranscript, 'whisper');
              console.log(`[YouTubeLocal] Successfully re-transcribed with local Whisper due to low English coverage`);
              const whisperCoverage = calculateTranscriptCoverage(whisperTranscript.segments, videoInfo.duration);
              return { 
                transcript: whisperTranscript, 
                fromCache: false, 
                videoTitle: videoInfo.title,
                videoDuration: videoInfo.duration,
                transcriptCoverage: whisperCoverage,
                whisperReason: 'low_coverage'
              };
            } catch (whisperError: any) {
              console.error(`[YouTubeLocal] Local Whisper fallback failed, using original English transcript:`, whisperError.message);
              // Fall through to use the original transcript
            }
          }
        }

        // Cache the transcript
        cacheTranscript(videoId, 'en', transcript, 'youtube');

        const coverage = calculateTranscriptCoverage(segments, videoInfo.duration);
        return { 
          transcript, 
          fromCache: false, 
          videoTitle: videoInfo.title,
          videoDuration: videoInfo.duration,
          transcriptCoverage: coverage
        };
      } catch {
        // Fall through to error
      }
    }

    // Try without language specification
    try {
      console.log(`[YouTubeLocal] Trying auto-detect subtitles for ${videoId}...`);
      const transcriptItems = await YoutubeTranscript.fetchTranscript(videoId);
      console.log(`[YouTubeLocal] Found ${transcriptItems.length} auto-detected subtitle segments`);

      // Treat empty transcript as failure - trigger Whisper fallback
      if (!transcriptItems || transcriptItems.length === 0) {
        console.log(`[YouTubeLocal] No auto-detected subtitle segments found for ${videoId}, treating as no subtitles`);
        throw new Error('NO_SUBTITLE_SEGMENTS');
      }

      const segments: TranscriptSegment[] = transcriptItems.map((item) => ({
        text: item.text,
        offset: msToSeconds(item.offset),
        duration: msToSeconds(item.duration),
      }));

      const transcript: Transcript = {
        videoId,
        language: 'auto',
        segments,
        isAutoGenerated: true,
      };

      // Check transcript coverage - fall back to local Whisper if coverage is too low
      if (useWhisperFallback && videoInfo.duration > 0) {
        const coverageMeetsThreshold = checkTranscriptCoverage(segments, videoInfo.duration);
        if (!coverageMeetsThreshold) {
          console.log(`[YouTubeLocal] Auto-detected transcript coverage too low, falling back to local Whisper for ${videoId}...`);
          try {
            const whisperTranscript = await getTranscriptWithLocalWhisper(
              videoId,
              preferredLanguage
            );
            whisperTranscript.isAutoGenerated = false;
            cacheTranscript(videoId, preferredLanguage, whisperTranscript, 'whisper');
            console.log(`[YouTubeLocal] Successfully re-transcribed with local Whisper due to low auto-detected coverage`);
            const whisperCoverage = calculateTranscriptCoverage(whisperTranscript.segments, videoInfo.duration);
            return { 
              transcript: whisperTranscript, 
              fromCache: false, 
              videoTitle: videoInfo.title,
              videoDuration: videoInfo.duration,
              transcriptCoverage: whisperCoverage,
              whisperReason: 'low_coverage'
            };
          } catch (whisperError: any) {
            console.error(`[YouTubeLocal] Local Whisper fallback failed, using original auto-detected transcript:`, whisperError.message);
            // Fall through to use the original transcript
          }
        }
      }

      // Cache the transcript
      cacheTranscript(videoId, 'auto', transcript, 'youtube');

      const coverage = calculateTranscriptCoverage(segments, videoInfo.duration);
      return { 
        transcript, 
        fromCache: false, 
        videoTitle: videoInfo.title,
        videoDuration: videoInfo.duration,
        transcriptCoverage: coverage
      };
    } catch (finalError) {
      // If Whisper fallback is enabled, try local speech-to-text
      if (useWhisperFallback) {
        console.log(`[YouTubeLocal] No subtitles found for ${videoId}, using local Whisper speech-to-text...`);
        try {
          const whisperTranscript = await getTranscriptWithLocalWhisper(
            videoId,
            preferredLanguage
          );
          
          // Mark as speech-to-text generated
          whisperTranscript.isAutoGenerated = false;
          
          // Cache the Whisper transcript
          cacheTranscript(videoId, preferredLanguage, whisperTranscript, 'whisper');
          
          console.log(`[YouTubeLocal] Successfully transcribed with local Whisper`);
          const whisperCoverage = calculateTranscriptCoverage(whisperTranscript.segments, videoInfo.duration);
          return { 
            transcript: whisperTranscript, 
            fromCache: false, 
            videoTitle: videoInfo.title,
            videoDuration: videoInfo.duration,
            transcriptCoverage: whisperCoverage,
            whisperReason: 'no_subtitles'
          };
        } catch (whisperError: any) {
          console.error(`[YouTubeLocal] Local Whisper transcription failed:`, whisperError.message);
          // If Whisper also fails, throw the original error
          throw parseYouTubeError(finalError, videoId);
        }
      }
      
      // Parse and throw specific YouTube error
      throw parseYouTubeError(finalError, videoId);
    }
  }
}
